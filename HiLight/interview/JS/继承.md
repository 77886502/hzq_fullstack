# JS继承

1. 原型链式继承
```js
function Animal(){
    this.type = "animal";
    this.show = ["dog"];
}
function Dog(name,age){
    this.name = name;
    this.age = age;
}
Dog.prototype = new Animal();
let doge = new Dog("doge",7);
let cheems = new Dog("cheems",3);
doge.show.push("doge");
cheems.show.push("cheems");
console.log(Dog.prototype.show); // ["dog","doge","cheems"]
```
> 原型链式继承会让所有的实例都继承自一个原型对象的属性和方法。当原型对象上的某个属性和方法发生改动时，所有的实例都会受此影响。而且实例可以借助原型链来篡改原型对象上的引用类型的属性的值（**当原型对象的属性为引用类型时，如果通过修改该引用类型的属性，会直接修改原型上面的引用类型。**），进而导致上述种情况的发生。





2. 借助call
```js
function Animal(){
    this.type = "animal";
    this.sayHello = function(){
        console.log(`Hello`)
    }
}
Animal.prototype.show = "doge"; 
Animal.prototype.sayName = function(){
    console.log(`My name is ${this.name}`);
};
function Dog(name,age){
    this.name = name;
    this.age = age;
    this.sayGoodBye = function(){
        console.log(`GoodBye`)
    }
    Animal.call(this);
}
Dog.prototype.main = ["doge"]; 
Dog.prototype.sayAge = function(){
    console.log(`My age is ${this.age}`);
};
let doge = new Dog("doge",7);

console.log(doge.main); // ["doge"]
// 无法 继承 call实现继承的原型的属性和方法 
console.log(doge.sayName); // undefined
console.log(doge.show); //undefinded
```
> 借助 `call` 实现的继承，实例对象可以继承父类的属性和方法，但无法继承父类原型对象上的方法和属性。

- 无法继承父类原型对象上的方法和属性，why?
借助 `call` 调用函数并没有像 `new` 执行过程中一样，与之关联一个原型对象，因此不存在继承一说。

3. 组合继承
```js
  function Parent3 () {
    this.name = 'parent3';
    this.play = [1, 2, 3];
  }
  function Child3() {
    Parent3.call(this);
    this.type = 'child3';
  }
  Child3.prototype = new Parent3();
  var s3 = new Child3();
  var s4 = new Child3();
  s3.play.push(4);
  console.log(s3.play, s4.play);
```

4. 原型式继承




5. 寄生式继承



6. 寄生式组合式继承