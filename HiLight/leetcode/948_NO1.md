# 948. 令牌放置（中等）｜刷题打卡
# 题目描述
你的初始 **能量** 为 P，初始 **分数** 为 0，只有一包令牌 tokens 。其中 tokens[i] 是第 i 个令牌的值（下标从 0 开始）。

令牌可能的两种使用方法如下：

如果你至少有 tokens[i] 点 **能量** ，可以将令牌 i 置为正面朝上，失去 tokens[i] 点 **能量** ，并得到 1 **分** 。
如果我们至少有 1 **分** ，可以将令牌 i 置为反面朝上，获得 tokens[i] 点 **能量** ，并失去 1 **分** 。
每个令牌 最多 只能使用一次，使用 顺序不限 ，不需 使用所有令牌。

在使用任意数量的令牌后，返回我们可以得到的最大 **分数** 。

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/bag-of-tokens/)

示例 1：
```
输入：tokens = [100], P = 50
输出：0
解释：无法使用唯一的令牌，因为能量和分数都太少了。
```
示例 2：
```
输入：tokens = [100,200], P = 150
输出：1
解释：令牌 0 正面朝上，能量变为 50，分数变为 1 。不必使用令牌 1 ，因为你无法使用它来提高分数。
```
示例 3：
```
输入：tokens = [100,200,300,400], P = 200
输出：2
解释：按下面顺序使用令牌可以得到 2 分：
1. 令牌 0 正面朝上，能量变为 100 ，分数变为 1
2. 令牌 3 正面朝下，能量变为 500 ，分数变为 0
3. 令牌 1 正面朝上，能量变为 300 ，分数变为 1
4. 令牌 2 正面朝上，能量变为 0 ，分数变为 2

```
提示：
- 0 <= tokens.length <= 1000
- 0 <= tokens[i], P < 104


# 思路分析
这道题目可以简单描述为 **可以用能量兑换分数也能用分数兑换能量，但最终结果的要求是返回在此过程中分数的最大值。** 确定了这个最终结果后，我们首先可以得到这样一些问题
1. 我们应该如何用能量兑换分数来获得最大收益？
2. 我们应该如何用分数兑换能量来获得最大收益？

下面我们开始分析这两个问题，采用的是贪心算法的思想
## 能量兑换分数获得最大收益分析

这里只考虑仅用能量兑换分数获得得最大收益的情况，显然用现有能量 `nowPower` 去兑换 当前最小能量卡牌的分数，因为每张卡牌能获取的分数都为 1，但用能量兑换分数需要满足现有能量大于或等于当前最小能量的卡牌 即 `nowPower > tokens[min]`。

## 分数兑换能量获得最大收益分析

这里只考虑仅用分数兑换能量的获得最大收益的情况，显然用现有的分数 `nowScore` 去兑换 当前最大能量卡牌的能量。因为获取每张卡牌的能量都只需要一分。但用分数兑换能量需要满足现有分数大于0 即 `nowPower > 0`。


分析完上述问题，你就会慢慢地意识到题目的答案必定是两者的结合。所以我们如何将两者结合一起？**补充题目的一些要求：每个令牌 最多只能使用一次，使用顺序不限 ，不需使用所有令牌。**
我找出最大的分数`maxScore`的思路大概是这样的：
1. 首先用初始能量`P`去兑换分数，找最小能量卡牌，直至当前能量小于当前最小能量的卡牌 即 `nowPower < tokens[min]`。当然如果初始能量就小于最小能量卡牌 即 `P < tokens[min] `，直接返回 0。
2. 基于第一点，如果当前能量不足以让你去兑换分数，但当前分数满足 `nowScore > 0`，你可以用分数去兑换最大能量的卡牌。但有个前提：如果只剩下两张卡牌了，这样做是没有任何意义的，可以返回记录过程中的最大分数`maxScore`！当然如果当前分数 `nowScore` 为 0，且无法通过能量兑换分数那么就直接返回整个过程中记录的最大分数 `maxScore`。
3. 重复第一点和第二点，并在此过程中记录最大分数 `maxScore`。


## 参考代码
```js
var bagOfTokensScore = function(tokens, P) {
    tokens.sort((a, b) => a - b);
    let nowScore = 0;
    while(true)
    {
        if(P >= tokens[0])
        {
            nowScore++;
            P -= tokens[0]; 
            tokens.shift();
        }
        else if (nowScore == 0)
            return nowScore;
        else if(tokens.length>2&&tokens[tokens.length-1] >= tokens[0])
        {
            P=tokens[tokens.length-1]+P-tokens[0];
            tokens.shift();
            tokens.pop();
        }
        else
            return nowScore;
    }
};
```
描述一下代码的做法上：
1. 我先对数组进行了升序排序，为了直接找到数组中最大能量卡牌 `tokens[max] = tokens[tokens.length-1]` 和最小能量卡牌 `tokens[min] = tokens[0]`。同时也为后面对卡牌数组删除元素提供方便。
2. 我写出代码中并没有声明`maxScore`，原因是思路的第二点补充了 `如果只剩下两张卡牌了，这样做是没有任何意义。` 的限定条件就能够使得返回的 `nowScore = maxScore`。这一点如果不实验几次，一般来说领悟不到！

对于Aarry.prototype.sort()的排序时间复杂度不同浏览器的解释各不相同(想了解可参考文章[深入浅出 JavaScript 的 Array.prototype.sort 排序算法](https://segmentfault.com/a/1190000010648740))，但除了`tokens.sort((a, b) => a - b)`外的代码的时间复杂度为 `O(n)` ,空间复杂度`O(n)`。

我知道对于这道题目还有很多的做法，在此我只分享了一番个人见解，如有对这道题目更多其他做法感兴趣的话，请移步[LeetCode题解](https://leetcode-cn.com/problems/bag-of-tokens/solution/)。

## 最后
这是我的LeetCode刷题打卡的`No.1`篇，还有后续篇章等待更新。如果觉得这篇LeetCode的题解分享还不错，欢迎点赞😄

本文正在参与「掘金 3 月闯关活动」，点击查看[活动详情](https://juejin.cn/post/6934506742986309639)。